% !TEX TS-program = xelatex
% !TEX encoding = UTF-8 Unicode
\documentclass[gap.tex]{subfiles}
\begin{document}
\label{sec:bonus-distance-use}

\begin{quote}
    For all distance point calculations, including the difficulty calculations
    in hang-gliding (see ~\ref{sec:difficulty-calculation}), these new stopped
    distance values are being used to determine the pilotsâ€™ best distance
    values.  Time and leading point calculations remain the same: they are not
    affected by the altitude bonus or stopped distance values. 
\end{quote}

This appendix, expands on this brief but broad statement (see
~\ref{sec:distance-stopped-tasks}) showing how and when bonus distance or real
distance is used in calculating validities and weights and when allocating
points.

\begin{lstlisting}[style=base, caption={Launch validity doesn't depend on distance inputs.}]
double launch_validity =
    CalcLaunchValidity
        ( sp.No_of_pilots_flying
        , sp.No_of_pilots_present
        , sfg
        );
\end{lstlisting}

\begin{lstlisting}[style=base, caption={Time validity depends on \textcolor{red}{bonus} distance input.}]
double @>time_validity@> =
    CalcTimeValidity
        ( time_validity_time
        , (double)sfg.Nom_time
        , sp.@>Best_dist@>
        , sfg.Nom_dist
        );
\end{lstlisting}

\begin{lstlisting}[style=base, caption={Distance validity depends on \textcolor{blue}{real} distance inputs.}]
double <@distance_validity<@ =
    CalcDistanceValidity
        ( sp.<@Sum_real_dist_over_min<@
        , sp.No_of_pilots_flying
        , (double)sfg.Nom_goal
        , sfg.Nom_dist
        , sfg.Min_dist
        , sp.<@Best_real_dist<@
        );
\end{lstlisting}

\begin{lstlisting}[style=base, caption={Stop validity depends on \textcolor{blue}{real} distance inputs.}]
sp.<@Sum_flown_distances<@ += p.<@_real_distance<@;
<@distances<@[distance_counter++] = p.<@_real_distance<@;

double <@avg_distance<@ = sp.<@Sum_flown_distances<@ / sp.No_of_pilots_flying;
double <@sumOfDerivation<@ = 0;
for (int i = 0; i < distances.Length; i++)
{
  <@sumOfDerivation<@ += <@distances<@[i] * <@distances<@[i];
}
double <@sumOfDerivationAverage<@ = <@sumOfDerivation<@ / sp.No_of_pilots_flying;
double <@stdev_distance<@ = Math.Sqrt(<@sumOfDerivationAverage<@ - (<@avg_distance<@ * <@avg_distance<@));

double <@stop_validity<@ =
    CalcStopValidity
        ( sfg
        , sp.Last_start_time
        , task_state.TaskStopTime
        , sp.<@Best_real_dist<@
        , sp.Launch_to_ess_distance
        , <@avg_distance<@
        , <@stdev_distance<@
        , sp.No_of_pilots_landed_before_stop
        , sp.No_of_pilots_flying
        , sp.No_of_pilots_reaching_ES
        , task_state.IsStopped
        );
\end{lstlisting}

\begin{lstlisting}[style=base, caption={Day quality depends on \textcolor{red}{bonus} distance.}]
double @>day_quality@> =
    CalcDayQuality
        ( @>time_validity@>
        , launch_validity
        , <@distance_validity<@
        , <@stop_validity<@
        );
\end{lstlisting}

\begin{lstlisting}[style=base, caption={Arrival weight and departure weight don't depend on distance inputs.}]
double dummy_arr_weight = 0;
if (sfg.Use_arrival_time_points && !sfg.Use_leading_points)
    dummy_arr_weight = (1.0 - sp.Distance_weight) / 4.0;
else
    dummy_arr_weight = (1.0 - sp.Distance_weight) / 8.0;

if (sp.No_of_pilots_reaching_ES > 0)
{
    if (sfg.Use_arrival_points)
        sp.Arrival_weight = dummy_arr_weight;

    if (sfg.Use_departure_points)
        sp.Departure_weight = dummy_arr_weight * 1.4;
}
\end{lstlisting}

\begin{lstlisting}[style=base, caption={Distance weight doesn't depend on distance inputs.}]
sp.GoalRatio = 0;
if (sp.Best_time > 0 && sfg.Use_time_points)
{
    sp.Max_time_to_get_time_points = sp.Best_time + Math.Sqrt(sp.Best_time);
    foreach (Participant p in ps)
    {
        double time = p.Result.Ss_Time_Dec_Hours;
        if (time > 0
           && time < sp.Max_time_to_get_time_points
           && (sfg.Time_points_if_not_in_goal > 0 || p.<@RealDistance<@ >= t.DistanceExact))
            sp.<@No_of_pilots_with_time_points<@++;
    }
    sp.GoalRatio = sp.No_of_pilots_reaching_goal * 1.0 / sp.No_of_pilots_flying;
}
sp.Distance_weight =
    0.9
    - 1.665 * sp.GoalRatio
    + 1.713 * Math.Pow(sp.GoalRatio, 2)
    - 0.587 * Math.Pow(sp.GoalRatio, 3);
\end{lstlisting}

\begin{lstlisting}[style=base, caption={Leading weight depends on \textcolor{red}{bonus} distance.}]
if (sp.No_of_pilots_reaching_goal == 0
    && sfg.Use_proportional_leading_weight_if_nobody_in_goal)
{
    sp.Leading_weight = Math.Min(sp.@>Best_dist@> / sp.Task_distance * 0.1d, 0.1d);
}
else
{
    sp.Leading_weight = dummy_arr_weight * 1.4;
    if (sfg.Double_leading_weight)
        sp.Leading_weight *= 2;
}
\end{lstlisting}

\begin{lstlisting}[style=base, caption={Time weight depends on \textcolor{red}{bonus} distance.}]
sp.@>Time_weight@> =
    (1 - sp.Distance_weight)
    - sp.Arrival_weight
    - sp.Departure_weight
    - sp.@>Leading_weight@>;
\end{lstlisting}

\end{document}
