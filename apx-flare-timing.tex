% !TEX TS-program = xelatex
% !TEX encoding = UTF-8 Unicode
\documentclass[gap.tex]{subfiles}
\begin{document}
The \href{https://github.com/BlockScope/flare-timing}{flare-timing}
implementation of GAP is a collection of apps, one for each step of the scoring
process, see Fig~\ref{fig:flare-timing}. Not being a single app that can store
intermediate results in memory, its workings and final results are written to
file with enough detail and evidence so that everything can be checked by hand.

\subsection{Scoring Sequence of Steps}

\begin{figure}[!ht]
    \centering
    \input{dia/flare-timing}
    \caption{Scoring as numbered steps from {\color{blue}original inputs} to
    {\color{csv}\texttt{*.csv}} or \texttt{*.yaml} outputs.}
    \label{fig:flare-timing}
\end{figure}

Starting with an \texttt{*.fsdb} comp and related \texttt{*.igc} or
\texttt{*.kml} track logs, the scoring process proceeds along this 
sequence of steps where outputs from earlier steps may be referred to later on;
\begin{enumerate}
    \item
        Extract the inputs with
        \href{https://github.com/BlockScope/flare-timing/tree/master/flare-timing/prod-apps/extract-input}{extract-input}.
    \item
        Trace the route of the shortest path to fly a task with
        \href{https://github.com/BlockScope/flare-timing/tree/master/flare-timing/prod-apps/task-length}{task-length}.
    \item
        Find pairs of fixes crossing over zones with
        \href{https://github.com/BlockScope/flare-timing/tree/master/flare-timing/prod-apps/cross-zone}{cross-zone}.
    \item
        Interpolate between crossing fixes for the time and place where a track
        tags a zone with
        \href{https://github.com/BlockScope/flare-timing/tree/master/flare-timing/prod-apps/tag-zone}{tag-zone}.
    \item
        Index fixes from the time of first crossing with
        \href{https://github.com/BlockScope/flare-timing/tree/master/flare-timing/prod-apps/align-time}{align-time}.
    \item
        Discard fixes that get further from goal and note leading area with
        \href{https://github.com/BlockScope/flare-timing/tree/master/flare-timing/prod-apps/discard-further}{discard-further}.
    \item
        Mask a task over its tracklogs with
        \href{https://github.com/BlockScope/flare-timing/tree/master/flare-timing/prod-apps/mask-track}{mask-track}.
    \item
        Group and count land outs with
        \href{https://github.com/BlockScope/flare-timing/tree/master/flare-timing/prod-apps/land-out}{land-out}.
    \item
        Score the competition with
        \href{https://github.com/BlockScope/flare-timing/tree/master/flare-timing/prod-apps/gap-point}{gap-point}.  
\end{enumerate}

\newpage
\subsection{Extracting Inputs}
In the \texttt{*.fsdb} FS keeps both inputs and outputs. We're only interested
in a subset of the input data, just enough to do the scoring;

\begin{description}
    \item[Competition] id, name, location, dates and UTC offset.
    \item[Nominal] launch, goal, time, distance and minimal distance.
    \item[Task] name and type of task, zones, speed section, start gates and pilots.
    \item[Zone] name, latitude, longitude and altitude and radius if a cylinder
    \item[Pilot] name and either absentee status or track log file name.
\end{description}

Something to be aware of when parsing the \texttt{XML} of the \texttt{*.fsdb}
is that attributes may be missing and in that case we'll have to infer the
defaults used by FS. This is done by looking at the source code of FS as there
is no schema for the \texttt{XML} that could also be used to set default
values.

\begin{lstlisting}[language=XML, caption={Overall *.fsdb structure, filtered for input.}]
<Fs>
  <FsCompetition id="7592" name="2012 Hang Gliding Pre-World Forbes" location="Forbes, Australia"
      from="2012-01-05" to="2012-01-14" utc_offset="11">
    <!-- Nominals are set once for a competition but beware, they are repeated per task. -->
    <FsScoreFormula min_dist="5" nom_dist="80" nom_time="2" nom_goal="0.2" />
    <FsParticipants>
      <FsParticipant id="23" name="Gerolf Heinrichs" />
      <FsParticipant id="106" name="Adam Parer" />
    </FsParticipants>
      <!-- Flags on how to score are also set for the competition but pick them up from the task. -->
      <FsTask name="Day 8" tracklog_folder="Tracklogs\day 8">
        <FsScoreFormula use_distance_points="1" use_time_points="1" use_departure_points="0" use_leading_points="1" use_arrival_position_points="1" use_arrival_time_points="0" />
        <FsTaskDefinition ss="2" es="5" goal="LINE" groundstart="0">
          <!-- Not shown here but each FsTurnpoint has open and close attributes. -->
          <FsTurnpoint id="FORBES" lat="-33.36137" lon="147.93207" radius="100" />
          <FsTurnpoint id="FORBES" lat="-33.36137" lon="147.93207" radius="10000" />
          <FsTurnpoint id="MARSDE" lat="-33.75343" lon="147.52865" radius="5000" />
          <FsTurnpoint id="YARRAB" lat="-33.12908" lon="147.57323" radius="400" />
          <FsTurnpoint id="DAY8GO" lat="-33.361" lon="147.9315" radius="400" />
          <!-- This was an elapsed time task so no start gates. -->
        </FsTaskDefinition>
        <FsTaskState stop_time="2012-01-14T17:22:00+11:00" />
        <FsParticipants>
          <!-- An empty participant element is a pilot absent from the task. -->
          <FsParticipant id="106" />
          <FsParticipant id="23">
            <FsFlightData tracklog_filename="Gerolf_Heinrichs.20120114-100859.6405.23.kml" />
          </FsParticipant>
        </FsParticipants>
      </FsTask>
    </FsTasks>
  </FsCompetition>
</Fs>
\end{lstlisting}

\subsection{Finding Zone Crossings}

First off, before we can determine if any zones have been crossed we'll have to
decide how to tell which parts of a track log are flown and which are walked or
driven in the retrieve car, possibly even back to goal.\footnote{Some pilots'
track logs will have initial values way off from the location of the device.
I suspect that the GPS logger is remembering the position it had when last
turned off, most likely at the end of yesterday's flight, somewhere near where
the pilot landed that day. Until the GPS receiver gets a satellite fix and can
compute the current position the stale, last known, position gets logged. This
means that a pilot may turn on their instrument inside the start circle but
their tracklog will start outside of it.}

\begin{lstlisting}[caption={Which fixes are considered flown, \texttt{flying} nodes of \texttt{*.cross-zone.yaml}.}]
flying:
  - - Gerolf Heinrichs
    - loggedFixes: 4786
      flyingFixes:
      - 293
      - 4775
      loggedSeconds: 19140
      flyingSeconds:
      - 1172
      - 19100
      loggedTimes:
      - 2012-01-14T02:00:05Z
      - 2012-01-14T07:19:05Z
      flyingTimes:
      - 2012-01-14T02:19:37Z
      - 2012-01-14T07:18:25Z
\end{lstlisting}

\subsubsection{Which Fixes are Flown?}
To work out when a pilot is flying, chop their track log into segments that are
close to one another, within ± 1m altitude or within ± 1/10,000th of a degree
of latitude or longitude. Then we count the number of fixes close together.

\begin{lstlisting}[language=Haskell, caption={Runs of fixes close together.}]
-- [3, 2, 2, 1, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-- 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-- 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-- ...
-- Lots of 1s elided and then we get to the end of the flight, moving the
-- glider, packing up, taking a ride in the retrieve vehicle back to the
-- airfield.
-- ...
-- 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-- 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-- 1, 1, 1, 1, 1, 1, 1, 2, 5, 1, 1, 2, 1, 2, 2, 1, 6, 3, 1, 5, 1, 1, 1, 4, 4,
-- 3, 1, 5, 1, 4, 1, 5, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 4, 1, 1, 1, 2, 1, 3,
-- 1, 1, 3, 2, 3, 2, 1, 2, 1, 1, 1, 2, 1, 2, 3, 5, 1, 2, 3, 1, 6, 1, 1, 1, 5,
-- 1, 3, 1, 1, 1, 4, 1, 7, 1, 2, 1, 1, 3, 28, 3, 5, 1, 19, 1, 4, 1, 7, 1, 3, 1,
-- 5, 1, 11, 1, 10, 1, 2, 1, 9, 1, 3, 2, 3, 7, 9, 7, 2, 7, 2, 1, 1, 1, 1, 5, 1,
-- 4, 1, 1, 1, 9, 1, 71, 2, 1, 2, 1, 1, 1, 1, 2, 3, 8, 1, 1, 1, 1, 1, 1, 1, 13,
-- 2, 1, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-- 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-- 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 1, 1, 3, 1, 1, 2, 1, 4, 1,
-- 3, 2, 3, 1, 5, 1, 5, 1, 8, 1, 1, 1, 4, 1, 5, 1, 7, 1, 1, 1, 1, 1, 1, 1, 1,
-- ...
-- 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2,
-- 1, 1, 1, 1, 1, 5, 2, 1, 2, 20, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-- 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 2,
-- 1, 3, 1, 2, 1, 4, 3, 2, 1, 1, 1, 1, 1, 3, 2, 1, 2, 1, 1, 1, 1, 1, 1, 5, 1,
-- 1, 1, 1, 2, 1, 2, 1, 1, 5, 1, 1, 2, 1, 2, 3, 1, 1, 3, 1, 2, 1]
\end{lstlisting}

Then grouping this list into lists of like elements, we get;

\begin{lstlisting}[language=Haskell, caption={Lists of runs.}]
-- [[3], [2, 2], [1], [5], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-- 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-- 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-- ...
-- 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-- 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-- 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
-- [2], [5], [1, 1], [2], [1], [2, 2], [1], [6], [3], [1], [5], [1, 1, 1], [4,
-- 4], [3], [1], [5], [1], [4], [1], [5], [1, 1, 1, 1], [2], [1, 1, 1, 1, 1],
-- [2], [4], [1, 1, 1], [2], [1], [3], [1, 1], [3], [2], [3], [2], [1], [2],
-- [1, 1, 1], [2], [1], [2], [3], [5], [1], [2], [3], [1], [6], [1, 1, 1], [5],
-- [1], [3], [1, 1, 1], [4], [1], [7], [1], [2], [1, 1], [3], [28], [3], [5],
-- [1], [19], [1], [4], [1], [7], [1], [3], [1], [5], [1], [11], [1], [10],
-- [1], [2], [1], [9], [1], [3], [2], [3], [7], [9], [7], [2], [7], [2], [1, 1,
-- 1, 1], [5], [1], [4], [1, 1, 1], [9], [1], [71], [2], [1], [2], [1, 1, 1,
-- 1], [2], [3], [8], [1, 1, 1, 1, 1, 1, 1], [13], [2], [1, 1], [8], [1, 1, 1,
-- 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-- 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-- 1, 1, 1, 1, 1, 1, 1, 1], [6], [1, 1], [3], [1, 1], [2], [1], [4], [1], [3],
-- [2], [3], [1], [5], [1], [5], [1], [8], [1, 1, 1], [4], [1], [5], [1], [7],
-- [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [3], [1, 1, 1], [3], [1,
-- 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-- 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-- 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-- 1, 1, 1, 1, 1, 1, 1, 1], [2], [3], [2], [1], [2], [1, 1, 1, 1, 1, 1], [2],
-- [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [68], [1], [2, 2],
-- [14], [1], [8], [1], [3], [1], [5], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-- 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [18],
-- [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-- 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-- 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-- 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [4], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-- 1, 1, 1, 1, 1, 1, 1], [15], [2], [7], [4], [13], [1], [3], [9], [1, 1, 1, 1,
-- 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-- 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-- 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-- 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-- 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-- 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-- 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-- 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-- 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-- 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-- 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-- 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-- 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
-- [15], [1, 1, 1, 1, 1], [2], [1, 1, 1], [2], [1], [2], [1, 1], [9], [1, 1,
-- 1], [20], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-- 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-- 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-- 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-- 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-- 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [2], [1, 1, 1, 1, 1], [5],
-- [2], [1], [2], [20], [2], [1, 1], [2], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-- 1, 1, 1, 1, 1, 1, 1], [2], [1, 1, 1, 1, 1, 1, 1], [2, 2], [1, 1, 1, 1, 1,
-- 1], [2], [1], [3], [1], [2], [1], [4], [3], [2], [1, 1, 1, 1, 1], [3], [2],
-- [1], [2], [1, 1, 1, 1, 1, 1], [5], [1, 1, 1, 1], [2], [1], [2], [1, 1], [5],
-- [1, 1], [2], [1], [2], [3], [1, 1], [3], [1], [2], [1]]
\end{lstlisting}

Then count the lengths of those groups and select the longest group as the
flown fixes.

\begin{lstlisting}[language=Haskell, caption={Count the lengths of lists of runs of the same length.}]
-- [1, 2, 1, 1, 7110, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 3, 2, 1, 1, 1, 1, 1, 1,
-- 1, 4, 1, 5, 1, 1, 3, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1,
-- 1, 1, 1, 3, 1, 1, 1, 3, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-- 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 1, 1, 1,
-- 3, 1, 1, 1, 1, 1, 1, 4, 1, 1, 1, 7, 1, 1, 2, 1, 61, 1, 2, 1, 2, 1, 1, 1, 1,
-- 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 16, 1, 3, 1, 84, 1, 1, 1, 1, 1,
-- 6, 1, 17, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 36, 1, 88, 1, 17, 1, 1, 1, 1, 1, 1,
-- 1, 1, 328, 1, 5, 1, 3, 1, 1, 1, 2, 1, 3, 1, 138, 1, 5, 1, 1, 1, 1, 1, 1, 2,
-- 1, 19, 1, 7, 2, 6, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 6, 1, 4, 1, 1,
-- 1, 2, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1]
--
-- The result is the range from the input list that selects these elements.
-- 
-- (5,7115)
\end{lstlisting}

Some track logs are particularly jumpy. In that case we can tolerate brief
jumps in an otherwise longer sequence.

\begin{lstlisting}[language=Haskell, caption={Example of a jumpy track log.}]
-- [1,1326,1,1,433,1,1,1,2447,1,1,270]
\end{lstlisting}

\subsection{Interpolating Zone Tagging}
\subsection{Time Aligning Flights}
\subsection{Incrementally Closer to Goal}
\subsection{Masking Task over Track}
\subsection{Assessing Difficulty}
\subsection{Collating Scores}

\end{document}
